/*
    == SOUL example code ==

    A simple sine-wave synthesiser featuring pitch-bend support, using a basic
    envelope and voice-allocator.
*/

graph SineSynth  [[ main ]]
{
    input gainParameter.volume [[ min: -40, max: 0,  init: -6, unit: "dB", step: 1, label: "Volume" ]];
    input event midi::Message midiIn;
    output stream float audioOut;

    let
    {
        midiParser = midi::MPEParser;

        voices = Voice[8];
        voiceAllocator = soul::VoiceAllocators::Basic(8);

        gainParameter = GainParameterRamp (1.0f);
        gainProcessor = soul::Gain::DynamicGain (float);
    }

    connection
    {
        midiIn -> midiParser.parseMIDI;

        midiParser.eventOut -> voiceAllocator.eventIn;

        // Plumb the voice allocator to the voices array
        voiceAllocator.voiceEventOut -> voices.noteOn,
                                        voices.noteOff,
                                        voices.pitchBend;

        // Sum the voices audio out to the output
        voices.audioOut -> gainProcessor.in;
        gainParameter.parameterOut -> gainProcessor.gain;
        gainProcessor.out -> audioOut;
    }
}

//==============================================================================
processor SineOsc
{
    input event
    {
        soul::NoteEvents::NoteOn noteOn;
        soul::NoteEvents::NoteOff noteOff;
        soul::NoteEvents::PitchBend pitchBend;
    }

    output stream float audioOut;

    event noteOn (soul::NoteEvents::NoteOn e)
    {
        notePitch = e.note;
        bendSemitones = 0.0f;
        calculatePhaseIncrement();
    }

    event noteOff (soul::NoteEvents::NoteOff e) {}

    event pitchBend (soul::NoteEvents::PitchBend e)
    {
        bendSemitones = e.bendSemitones;
        calculatePhaseIncrement();
    }

    float bendSemitones, notePitch, phase, phaseIncrement;

    void calculatePhaseIncrement()
    {
        let noteFrequency = soul::noteNumberToFrequency (notePitch + bendSemitones);
        phaseIncrement = noteFrequency / float (processor.frequency);
    }

    void run()
    {
        phaseIncrement = 0.1f;

        loop
        {
            phase = phase + phaseIncrement;

            while (phase > 1.0f)
                phase = phase - 1.0f;

            audioOut << sin (float (2.0f * pi * phase));
            advance();
        }
    }
}

//==============================================================================
graph Voice
{
    input event
    {
        soul::NoteEvents::NoteOn noteOn;
        soul::NoteEvents::NoteOff noteOff;
        soul::NoteEvents::PitchBend pitchBend;
    }

    output stream float audioOut;

    let
    {
        osc = SineOsc;
        amplitudeEnvelope = soul::Envelope::FixedAttackReleaseEnvelope (0.2f, 0.02f, 0.1f);
        attenuator = soul::Gain::DynamicGain (float);
    }

    connection
    {
        noteOn          -> osc.noteOn;
        noteOff         -> osc.noteOff;
        pitchBend       -> osc.pitchBend;
        noteOn, noteOff -> amplitudeEnvelope.noteIn;

        osc.audioOut                -> attenuator.in;
        amplitudeEnvelope.levelOut  -> attenuator.gain;
        attenuator.out              -> audioOut;
    }
}

//==============================================================================
// Converts an input event (as a gain in db) to a ramped stream
processor GainParameterRamp (float slewRate)
{
    input event float volume;
    output stream float parameterOut;

    event volume (float targetDb)
    {
        targetValue = soul::dBtoGain (targetDb);

        let diff = targetValue - currentValue;
        let rampSeconds = abs (diff) / slewRate;

        rampSamples   = int (processor.frequency * rampSeconds);
        rampIncrement = diff / float (rampSamples);
    }

    float targetValue;
    float currentValue;
    float rampIncrement;
    int rampSamples;

    void run()
    {
        loop
        {
            if (rampSamples > 0)
            {
                currentValue += rampIncrement;
                --rampSamples;
            }

            parameterOut << currentValue;
            advance();
        }
    }
}
